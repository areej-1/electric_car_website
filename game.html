<!DOCTYPE html>
<html lang="en">
    <head>
        <link rel="stylesheet" href="styles.css">
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="icon" href="favicon.png" type="image/png">
        <title>Electric Car Club</title>
    </head>
    <body>
        <nav>
            <div class="logo">SIS Al Jada Cobras</div>
            <ul>
                <li><a href="index.html">Home</a></li>
                <li><a href="members.html">Members</a></li>
                <li><a href="projects.html">Our Work</a></li>
                <li><a href="game.html">Game</a></li>
                <li><a href="101.html">Electric Cars 101</a></li>
            </ul>
        </nav>
        <main>
            <h1>Cobra Racing</h1>
            <div id="game-container">
                <div id="player"></div>
                <div id="score">Score: 0</div>
                <div id="level">Level: 1</div>
                <div id="level-overlay" class="hidden">
                    <div class="overlay-box">
                        <div id="overlay-text">LEVEL UP!</div>
                        <div id="overlay-subtext">Get readyâ€¦</div>
                    </div>
                    </div>


            </div>
            <button id="start-btn">Start Game</button>
</main>
<script>
    const container = document.getElementById('game-container');
    const player = document.getElementById('player');
    const scoreDisplay = document.getElementById('score');
    const startBtn = document.getElementById('start-btn');
    const overlay = document.getElementById('level-overlay');
    const overlayText = document.getElementById('overlay-text');
    const levelDisplay = document.getElementById('level');

    // Dynamic sizing - reads actual container/player dimensions
    function getGameDimensions() {
        const containerWidth = container.offsetWidth;
        const containerHeight = container.offsetHeight;
        const playerWidth = player.offsetWidth;
        const playerHeight = player.offsetHeight;
        return {
            containerWidth,
            containerHeight,
            playerWidth,
            playerHeight,
            maxPlayerX: containerWidth - playerWidth,
            playerTopY: containerHeight - playerHeight - 20,
            playerBottomY: containerHeight - 20
        };
    }

    let playerX = 0;
    let score = 0;
    let level = 1;
    let obstacleSpeed = 7;
    let batterySpeed = 5;
    let obstacleSpawnMs = 1500;
    let batterySpawnMs = 2000;

    const LEVEL_UP_EVERY = 50;
    let levelingUp = false;
    let gameRunning = false;
    let obstacleInterval;
    let batteryInterval;

    // Move player with left/right arrow keys
    document.addEventListener('keydown', (e) => {
        if (!gameRunning) return;
        const dims = getGameDimensions();
        const moveAmount = Math.max(20, dims.containerWidth * 0.05);

        if (['ArrowLeft', 'ArrowRight'].includes(e.key)) {
            e.preventDefault();
        }

        if (e.key === 'ArrowLeft' && playerX > 0) {
            playerX = Math.max(0, playerX - moveAmount);
        }
        if (e.key === 'ArrowRight' && playerX < dims.maxPlayerX) {
            playerX = Math.min(dims.maxPlayerX, playerX + moveAmount);
        }
        player.style.left = playerX + 'px';
    });

    // Touch controls
    container.addEventListener('touchstart', (e) => {
        if (!gameRunning) return;
        e.preventDefault();

        const dims = getGameDimensions();
        const moveAmount = Math.max(20, dims.containerWidth * 0.05);
        const touch = e.touches[0];
        const containerRect = container.getBoundingClientRect();
        const touchX = touch.clientX - containerRect.left;
        const containerMiddle = containerRect.width / 2;

        if (touchX < containerMiddle && playerX > 0) {
            playerX = Math.max(0, playerX - moveAmount);
        } else if (touchX >= containerMiddle && playerX < dims.maxPlayerX) {
            playerX = Math.min(dims.maxPlayerX, playerX + moveAmount);
        }
        player.style.left = playerX + 'px';
    });

    // Create falling obstacle (snake)
    function createObstacle() {
        const dims = getGameDimensions();
        const obstacle = document.createElement('div');
        obstacle.classList.add('obstacle');
        const obstacleWidth = 80; // Will be smaller on mobile via CSS
        const maxX = dims.containerWidth - obstacleWidth;
        obstacle.style.left = Math.random() * maxX + 'px';
        container.appendChild(obstacle);

        let obstacleY = -100;

        const fall = setInterval(() => {
            if (!gameRunning) {
                clearInterval(fall);
                obstacle.remove();
                return;
            }

            const currentDims = getGameDimensions();
            obstacleY += obstacleSpeed;
            obstacle.style.top = obstacleY + 'px';

            // Collision detection using actual dimensions
            const obstacleX = parseInt(obstacle.style.left);
            const obsWidth = obstacle.offsetWidth;
            const obsHeight = obstacle.offsetHeight;

            if (
                playerX + 10 < obstacleX + obsWidth - 10 &&
                playerX + currentDims.playerWidth - 10 > obstacleX + 10 &&
                currentDims.playerTopY < obstacleY + obsHeight &&
                currentDims.playerBottomY > obstacleY
            ) {
                gameOver();
            }

            if (obstacleY > currentDims.containerHeight) {
                obstacle.remove();
                clearInterval(fall);
            }
        }, 30);
    }

    // Create falling battery (collectible)
    function createBattery() {
        const dims = getGameDimensions();
        const battery = document.createElement('div');
        battery.classList.add('battery');
        const batteryWidth = 60;
        const maxX = dims.containerWidth - batteryWidth;
        battery.style.left = Math.random() * maxX + 'px';
        container.appendChild(battery);

        let batteryY = -60;

        const fall = setInterval(() => {
            if (!gameRunning) {
                clearInterval(fall);
                battery.remove();
                return;
            }

            const currentDims = getGameDimensions();
            batteryY += batterySpeed;
            battery.style.top = batteryY + 'px';

            // Collection detection
            const batteryX = parseInt(battery.style.left);
            const batWidth = battery.offsetWidth;
            const batHeight = battery.offsetHeight;

            if (
                playerX + 5 < batteryX + batWidth - 5 &&
                playerX + currentDims.playerWidth - 5 > batteryX + 5 &&
                currentDims.playerTopY < batteryY + batHeight &&
                currentDims.playerBottomY > batteryY
            ) {
                battery.remove();
                clearInterval(fall);
                score += 10;
                scoreDisplay.textContent = 'Score: ' + score;

                const newLevel = Math.floor(score / LEVEL_UP_EVERY) + 1;
                if (newLevel > level && !levelingUp) {
                    level = newLevel;
                    doLevelUp(level);
                }
            }

            if (batteryY > currentDims.containerHeight) {
                battery.remove();
                clearInterval(fall);
            }
        }, 30);
    }

    function doLevelUp(newLevel) {
        levelingUp = true;
        clearInterval(obstacleInterval);
        clearInterval(batteryInterval);

        overlayText.textContent = 'LEVEL ' + newLevel + '!';
        overlay.classList.remove('hidden');
        levelDisplay.textContent = 'Level: ' + newLevel;

        setTimeout(() => {
            overlay.classList.add('hidden');

            obstacleSpeed = 7 + (newLevel - 1) * 1.2;
            batterySpeed = 5 + (newLevel - 1) * 0.8;
            obstacleSpawnMs = Math.max(600, 1500 - (newLevel - 1) * 120);
            batterySpawnMs = Math.max(900, 2000 - (newLevel - 1) * 100);

            obstacleInterval = setInterval(createObstacle, obstacleSpawnMs);
            batteryInterval = setInterval(createBattery, batterySpawnMs);

            levelingUp = false;
        }, 1000);
    }

    function startGame() {
        const dims = getGameDimensions();

        level = 1;
        obstacleSpeed = 7;
        batterySpeed = 5;
        obstacleSpawnMs = 1500;
        batterySpawnMs = 2000;
        levelDisplay.textContent = 'Level: 1';
        overlay.classList.add('hidden');
        levelingUp = false;

        gameRunning = true;
        score = 0;
        playerX = (dims.containerWidth - dims.playerWidth) / 2;
        player.style.left = playerX + 'px';
        scoreDisplay.textContent = 'Score: 0';
        startBtn.style.display = 'none';
        obstacleInterval = setInterval(createObstacle, obstacleSpawnMs);
        batteryInterval = setInterval(createBattery, batterySpawnMs);
    }

    function gameOver() {
        gameRunning = false;
        clearInterval(obstacleInterval);
        clearInterval(batteryInterval);
        alert('Game Over! Score: ' + score);

        document.querySelectorAll('.obstacle').forEach(ob => ob.remove());
        document.querySelectorAll('.battery').forEach(b => b.remove());

        startBtn.style.display = 'block';
    }

    startBtn.addEventListener('click', startGame);
</script>
    <footer>
        <p> Copyright 2026 SIS Al Jada Cobras</p>
        <p>Made by Areej</p>
        <div class="socials">
            <a href="https://tiktok.com/@sisaljadacobras?_r=1&_t=ZS-935T-PczwWdL"><img src="tiktok.png" alt="description"></a>
            <a href="https://instagram.com/sisaljadacobras?igsh=dmRpbXlyMzVjNjV1"><img src="instagram.png" alt="description"></a>
        </div>
    </footer>
    </body>
</html>
